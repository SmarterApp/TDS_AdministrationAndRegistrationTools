/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.domain;

import static org.apache.commons.lang.StringUtils.isNotEmpty;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.CLIENT;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.GROUPOFSTATES;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.STATE;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import javax.validation.Valid;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

import org.hibernate.validator.constraints.NotBlank;
import org.opentestsystem.delivery.testreg.domain.constraints.Alpha;
import org.opentestsystem.delivery.testreg.domain.constraints.Ascii;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidAssociatedExternalId;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidParentEntityType;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidStateCode;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidStateRule;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.CompoundIndexes;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;

@SuppressWarnings({ "PMD.ShortVariable" })
@Document
@JsonIgnoreProperties(ignoreUnknown = true)
@XStreamAlias("User")
@CompoundIndexes({
        @CompoundIndex(name = "role", def = "{ 'roleAssociations.role': 1 }"),
        @CompoundIndex(name = "level", def = "{ 'roleAssociations.level': 1 }")
})
public class User implements Sb11NonEntity {

    private static final long serialVersionUID = 9111665898160871580L;
    private static final String GET_RESOURCE_NAME = "/user/";
    public static final FormatType FORMAT_TYPE = FormatType.USER;
    private final static List<String> sb11SuperEntityList = Arrays.asList(new String[] { CLIENT.name(), GROUPOFSTATES.name(), STATE.name() });
    private static final String EMAIL_REGEX = "[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?";

    @Id
    @XStreamAlias("UUID")
    private String id;

    // alpha only, length 35, required
    @NotBlank(message = "{user.firstname.blank}")
    @Indexed
    @Ascii(isExtended = true, message = "{user.firstname.alphanumeric}")
    @Size(max = 35, message = "{user.firstname.size.max}")
    @FieldLabel("FirstName")
    @XStreamAlias("FirstName")
    private String firstName;

    // alphanumeric with specials, length 35, required
    @Indexed
    @NotBlank(message = "{user.lastname.blank}")
    @Ascii(isExtended = true, message = "{user.lastname.alphanumeric}")
    @Size(max = 35, message = "{user.lastname.size.max}")
    @FieldLabel("LastOrSurname")
    @XStreamAlias("LastName")
    private String lastName;

    // length 128, email format, required
    @Indexed(unique = true)
    @NotBlank(message = "{user.email.blank}")
    @Size(max = 128, message = "{user.email.size.max}")
    @Pattern(regexp = EMAIL_REGEX, message = "{user.email.valid.address}")
    @FieldLabel("ElectronicMailAddress")
    @XStreamAlias("Email")
    private String email;

    // not required, format: ddd-ddd-dddd xdddddddddd, total length 24
    @Indexed
    @Size(max = 24, message = "{user.phone.size.max}")
    @Pattern(regexp = "^$|^\\d{3}-\\d{3}-\\d{4}( x\\d{1,10})?$", message = "{user.phone.format}")
    @FieldLabel("TelephoneNumber")
    @XStreamAlias("Phone")
    private String phone;

    // not required, could be Yes, everything else considered No, no need to validate value here
    @Alpha(message = "{delete.alpha}")
    @Size(max = 6, message = "{delete.size.max}")
    @FieldLabel("Delete")
    @XStreamOmitField
    private String delete;

    private String changeEventExportError = null;

    // flag to determine if user being edited or viewed has roles outside logged-in-user jurisdiction or not 
    @Transient
    private Boolean hasRolesOutside;

    @Valid
    @XStreamImplicit(itemFieldName = "Role")
    private List<RoleAssociation> roleAssociations = new ArrayList<>();

    @ValidAssociatedExternalId
    @ValidStateRule
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class RoleAssociation implements Comparable<RoleAssociation> {

        @XStreamOmitField
        private String associatedEntityMongoId;

        // 40 digit number, or 2 char state code if level == STATE
        @Size(max = 40, message = "{user.associatedentityid.size.max}")
        @NotBlank(message = "{user.associatedentityid.blank}")
        @FieldLabel("AssociatedEntityID")
        @XStreamAlias("RoleID")
        private String associatedEntityId;

        @Transient
        @XStreamOmitField
        private String associatedEntityName;

        // required,must match a valid role from permissions, must be a valid role for the level in hierarchy
        // role validity should go in business validations as db access will be needed
        @NotBlank(message = "{user.role.blank}")
        @FieldLabel("Role")
        @XStreamAlias("Name")
        private String role;

        // any hierarchy level
        @NotBlank(message = "{user.level.blank}")
        @ValidParentEntityType(types = { "STATE", "CLIENT", "GROUPOFSTATES", "DISTRICT", "GROUPOFDISTRICTS", "GROUPOFINSTITUTIONS", "INSTITUTION" }, message = "{user.level.invalid}")
        @FieldLabel("Level")
        @XStreamAlias("Level")
        private String level;

        // length of 2, alpha
        @ValidStateCode(message = "{user.stateabbreviation.invalid}")
        @FieldLabel("StateAbbreviation")
        @XStreamAlias("State")
        private String stateAbbreviation;

        public String getRole() {
            return role;
        }

        public void setRole(final String inRole) {
            this.role = inRole;
        }

        public HierarchyLevel getLevel() {
            return (level != null) ? HierarchyLevel.valueOf(level) : null;
        }

        @JsonProperty
        public void setLevel(final String inLevel) {
            this.level = inLevel;
        }

        public void setLevel(final HierarchyLevel inLevel) {
            if (inLevel != null) {
                this.level = inLevel.name();
            }
        }

        @SuppressWarnings ("unused")
        private static boolean isValidHierarchyLevel(final String level) {
            try {
                if (level != null) {
                    HierarchyLevel.valueOf(level);
                    return true;
                }
            } catch (Exception e) {
                // if we have a bogus level
            }
            return false;
        }

        private boolean isLevelSuperEntity() {
            return level != null && sb11SuperEntityList.contains(level);
        }

        public String getAssociatedEntityMongoId() {
            return associatedEntityMongoId;
        }

        public void setAssociatedEntityMongoId(final String inAssociatedEntityMongoId) {
            this.associatedEntityMongoId = inAssociatedEntityMongoId;
        }

        public String getAssociatedEntityId() {
            return associatedEntityId;
        }

        public void setAssociatedEntityId(final String inAssociatedEntityId) {
            this.associatedEntityId = inAssociatedEntityId;
        }

        public String getAssociatedEntityName() {
          return associatedEntityName;
        }

        public void setAssociatedEntityName(String value) {
          this.associatedEntityName = value;
        }

        public String getStateAbbreviation() {
            return stateAbbreviation;
        }

        public void setStateAbbreviation(final String inStateAbbreviation) {
            this.stateAbbreviation = inStateAbbreviation;
        }

        @Override
        public int hashCode() {
            if (isLevelSuperEntity()) {
                return com.google.common.base.Objects.hashCode(this.role, this.level, this.associatedEntityId);
            } else {
                return com.google.common.base.Objects.hashCode(this.role, this.level, this.associatedEntityId, this.stateAbbreviation);
            }
        }

        @Override
        public boolean equals(final Object obj) {
            if ((obj == null) || (getClass() != obj.getClass())) {
                return false;
            }
            final RoleAssociation other = (RoleAssociation) obj;
            boolean cond1 = com.google.common.base.Objects.equal(this.role, other.role);
            boolean cond2 = com.google.common.base.Objects.equal(this.level, other.level);
            boolean cond3 = com.google.common.base.Objects.equal(this.associatedEntityId, other.associatedEntityId);
            boolean cond4 = com.google.common.base.Objects.equal(this.stateAbbreviation, other.stateAbbreviation);
            return isLevelSuperEntity() ? cond1 && cond2 && cond3 : cond1 && cond2 && cond3 && cond4;
        }

        public String[] toStringArray() {
            String[] elements = { this.role, this.associatedEntityId, this.associatedEntityName, this.level, this.stateAbbreviation };
            return elements;
        }

        @Override
        public int compareTo(final RoleAssociation other) {
            boolean cond1 = com.google.common.base.Objects.equal(this.role, other.role);
            boolean cond2 = com.google.common.base.Objects.equal(this.level, other.level);
            boolean cond3 = com.google.common.base.Objects.equal(this.associatedEntityId, other.associatedEntityId);
            boolean cond4 = com.google.common.base.Objects.equal(this.stateAbbreviation, other.stateAbbreviation);
            if (cond1 && cond2 && cond3) {
                if (isLevelSuperEntity()) {
                    return 0;
                } else {
                    return cond4 ? 0 : -1;
                }
            } else {
                return -1;
            }
        }
    }

    public static class Builder implements TestRegistrationBuilder<User> {

        private final Object[] builderVals;

        public Builder(final Object... inVals) {
            this.builderVals = inVals;
        }

        @Override
        public User build() {
            User builtObject = new User();
            builtObject.setFirstName((String) builderVals[DomainIndexConstants.USER_FIRSTNAME_INDEX]);
            builtObject.setLastName((String) builderVals[DomainIndexConstants.USER_LASTNAME_INDEX]);
            builtObject.setEmail((String) builderVals[DomainIndexConstants.USER_EMAIL_INDEX]);
            builtObject.setPhone((String) builderVals[DomainIndexConstants.USER_PHONE_INDEX]);
            builtObject.setDelete((String) builderVals[DomainIndexConstants.USER_DELETE_INDEX]);
            RoleAssociation assoc = new User.RoleAssociation();
            assoc.setRole((String) builderVals[DomainIndexConstants.USER_ROLE_INDEX]);
            assoc.setAssociatedEntityId((String) builderVals[DomainIndexConstants.USER_ASSOCIATEDENTITYID_INDEX]);
            // Adding new column AssociatedEntityName in import file based on TO-15( SB-1426 ) requirement 3.9.2
            // for Harmonizing Export and Import File Formats new column added to import file and data in corresponding column is not validated or stored
            assoc.setLevel((String) builderVals[DomainIndexConstants.USER_LEVEL_INDEX]);
            assoc.setStateAbbreviation(isNotEmpty((String) builderVals[DomainIndexConstants.USER_STATE_ABBREVIATION_INDEX]) ? ((String) builderVals[DomainIndexConstants.USER_STATE_ABBREVIATION_INDEX]).toUpperCase() : "");
            builtObject.addRoleAssociation(assoc);
            return builtObject;
        }
    }

    public List<RoleAssociation> getRoleAssociations() {
        return roleAssociations;
    }

    // loop over and just add each one to allow for the state abbrev. check to happen in one spot
    public void setRoleAssociations(final List<RoleAssociation> inRoleAssociations) {
        roleAssociations.clear();
        for (RoleAssociation roleAssociation : inRoleAssociations) {
            addRoleAssociation(roleAssociation);
        }
    }

    public boolean addRoleAssociation(final RoleAssociation roleAssociation) {
        roleAssociations = (roleAssociations != null) ? roleAssociations : new ArrayList<RoleAssociation>();
        // if we are dealing with a role assoc. >= state, we do NOT want a state abbrev.
        if (roleAssociation.isLevelSuperEntity()) {
            roleAssociation.setStateAbbreviation(null);
        }
        if (!roleAssociations.contains(roleAssociation)) {
            roleAssociations.add(roleAssociation);
            return true;
        }
        return false;
    }

    public boolean addRoleAssociations(final List<RoleAssociation> roleAssociations) {
        boolean finalResult = true;
        for (RoleAssociation roleAssociation : roleAssociations) {
            finalResult = addRoleAssociation(roleAssociation) && finalResult;
        }
        return finalResult;
    }

    public void removeRoleAssociation(final RoleAssociation assoc) {
        this.roleAssociations.remove(assoc);
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public void setId(final String inId) {
        this.id = inId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(final String inFirstName) {
        this.firstName = inFirstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(final String inLastName) {
        this.lastName = inLastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(final String inEmail) {
        this.email = inEmail;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(final String inPhone) {
        this.phone = inPhone;
    }

    public String getDelete() {
        return delete;
    }

    public void setDelete(final String inDelete) {
        this.delete = inDelete;
    }

    public String getChangeEventExportError() {
        return changeEventExportError;
    }

    public void setChangeEventExportError(final String changeEventExportError) {
        this.changeEventExportError = changeEventExportError;
    }

    /**
     * @return true if the edit/view user has roles outside logged-in-user jurisdiction, otherwise false
     */
    public Boolean getHasRolesOutside () {
      return hasRolesOutside;
    }

    /**
     *
     * @param hasRolesOutside hasRolesOutside to set ( true/false )
     *        true indicates edit/view user has roles outside logged-in-user jurisdiction,
     *        Otherwise false
     */
    public void setHasRolesOutside (Boolean hasRolesOutside) {
      this.hasRolesOutside = hasRolesOutside;
    }

    @Override
    public FormatType getFormatType() {
        return FORMAT_TYPE;
    }

    @Override
    public int hashCode() {
        if (this.getEmail() != null) {
            int userHashCode = 0;
            userHashCode = 31 * userHashCode + this.getEmail().hashCode();
            return userHashCode;
        }
        return super.hashCode();
    }

    @Override
    public boolean equals(final Object obj) {
        User userObj = (User) obj;
        return (this.getEmail() != null && (this.getEmail().equals(userObj.getEmail())));
    }

    @Override
    public String[] toStringArray() {
        String[] elements = { this.getFirstName(), this.getLastName(), this.getEmail(), this.getPhone() };
        return elements;
    }

    // TODO this is not needed and will change globally
    @Override
    public Action getAction() {
        return "DELETE".equals(delete) ? Action.DEL : Action.UPD;
    }

    @JsonProperty
    public String getUrl() {
        return GET_RESOURCE_NAME + this.id;
    }

    @Override
    public String getAlternateKey() {
        return new StringBuilder().append("email: ").append(email).toString();
    }

    @Override
    public AbstractSearchRequest createAlternateKeySearchRequest() {
        Map<String, String[]> reqMap = new HashMap<>();
        reqMap.put(UserSearchRequest.SEARCH_KEY_EMAIL_INSENSITIVE, new String[] { email });
        UserSearchRequest request = new UserSearchRequest(reqMap);
        return request;
    }

    /**
     * Determine if this {@link org.opentestsystem.delivery.testreg.domain.User} is the same as another
     * {@link org.opentestsystem.delivery.testreg.domain.User}.
     * <p>
     *     This method is used by the bulk upload process to determine if a
     *     {@link org.opentestsystem.delivery.testreg.domain.UserChangeEvent} needs to be created to notify the
     *     downstream user management system (i.e. OpenDJ) of any changes to the user's account.
     * </p>
     * <p>
     *     The reason this method exists is because {@link org.opentestsystem.delivery.testreg.domain.User#equals(Object)}
     *     is already overridden in this class.  Rather than potentially breaking the program by  changing how the
     *     {@link #equals(Object)} method works, this method has been introduced to determine if/when a
     *     {@link org.opentestsystem.delivery.testreg.domain.User} needs to be updated.
     * </p>
     * @param other The {@link org.opentestsystem.delivery.testreg.domain.User} to compare this user to
     * @return True if this user is the same as the user that was compared against; otherwise false.
     */
    public boolean isSameAs(final User other) {
        return Objects.equals(getId(), other.getId())
                && Objects.equals(getFirstName(), other.getFirstName())
                && Objects.equals(getLastName(), other.getLastName())
                && Objects.equals(getEmail(), other.getEmail())
                && Objects.equals(getPhone(), other.getPhone())
                && Objects.equals(getRoleAssociations(), other.getRoleAssociations());
    }
}