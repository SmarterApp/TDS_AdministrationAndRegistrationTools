package org.opentestsystem.delivery.testreg.rest.diagnostic.client;

import com.google.common.base.Optional;
import com.mongodb.BasicDBObject;
import com.mongodb.CommandResult;
import org.opentestsystem.delivery.testreg.rest.diagnostic.model.LatencyTest;
import org.opentestsystem.delivery.testreg.rest.diagnostic.model.OpLatencies;
import org.opentestsystem.delivery.testreg.rest.diagnostic.model.DiagnosticTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.util.StopWatch;
import tds.dll.common.diagnostic.domain.Level;

import java.util.Date;
import java.util.List;

import tds.dll.common.diagnostic.domain.Status;

import static org.opentestsystem.delivery.testreg.rest.diagnostic.DiagnosticUtil.setStatusError;
import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Query.query;

public class MongoDBHealthCheck {
    private static final String MONGODB_UNIT = "MongoDB";

    private final MongoTemplate mongoTemplate;

    public MongoDBHealthCheck(final MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    protected void setStatus(final Status status, final CommandResult commandResult) {
        if (!commandResult.ok()) {
            setStatusError(status, commandResult.getErrorMessage());
        }
    }

    protected CommandResult ping() {
        return mongoTemplate.getDb().command("ping");
    }

    protected CommandResult serverStatus() {
        return mongoTemplate.getDb().command("serverStatus");
    }

    static final String READ_KEY_NAME = "read-test-key";
    static final String WRITE_KEY_NAME = "write-test-key";
    static final String KEY_VALUE = "key-value";

    protected boolean readTestDocument() {
        List<DiagnosticTest> documents = mongoTemplate.find(query(where("key").is(READ_KEY_NAME)), DiagnosticTest.class);
        return !documents.isEmpty();
    }

    // setup first time read test
    protected void initializeReadTest() throws Exception {
        if (!readTestDocument()) {
            mongoTemplate.save(new DiagnosticTest(READ_KEY_NAME, KEY_VALUE));
        }
    }


    // returns measured latencies from mongo db in milliseconds
    protected long manualReadsLatency() throws Exception {
        initializeReadTest();

        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        boolean successful = readTestDocument();
        stopWatch.stop();

        if (!successful) throw new Exception("Cannot read test document from MongoDB.");

        return stopWatch.getTotalTimeMillis();
    }

    // returns measured latencies from mongo db in milliseconds
    protected long manualWritesLatency() throws Exception {
        DiagnosticTest diagnosticTest = new DiagnosticTest(WRITE_KEY_NAME, KEY_VALUE);
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        mongoTemplate.save(diagnosticTest);
        stopWatch.stop();
        mongoTemplate.remove(diagnosticTest);
        return stopWatch.getTotalTimeMillis();
    }

    // returns latencies reported from mongo db in milliseconds
    protected Optional<OpLatencies> getServerStatusLatencies() throws Exception {
        final CommandResult result = serverStatus();
        if (result.ok()) {
            final BasicDBObject dbObject = (BasicDBObject) result.get("opLatencies");
            if (dbObject != null) {
                OpLatencies opLatency = mongoTemplate.getConverter().read(OpLatencies.class, dbObject);
                return Optional.of(opLatency);
            }
        }

        return Optional.absent();
    }

    // reads server status latency and tests manual db operations
    protected long getLatency(LatencyTest manualLatencyTest) throws Exception {
        Optional<OpLatencies> opLatenciesOptional = getServerStatusLatencies();
        long manualLatency = manualLatencyTest.getLatency();
        if (!opLatenciesOptional.isPresent()) {
            return manualLatency;
        } else {
            return opLatenciesOptional.get().getReads().getLatency();
        }
    }

    /**
     * Read latency in milliseconds
     * @return
     */
    public long readsLatency() throws Exception {
        return getLatency(new LatencyTest() {
            @Override
            public long getLatency() throws Exception {
                return manualReadsLatency();
            }
        });
    }

    /**
     * Write latency in milliseconds
     * @return
     */
    public long writesLatency() throws Exception {
        return getLatency(new LatencyTest() {
            @Override
            public long getLatency() throws Exception {
                return manualWritesLatency();
            }
        });
    }

    /**
     * Calls server status on mongodb.
     * @see <a href="https://docs.mongodb.com/manual/reference/command/serverStatus">Server Status</a>
     * If an authorization error occurs, falls back to calling ping.
     * @see <a href="https://docs.mongodb.com/manual/reference/command/ping/">Ping</a>
     * @return diagnostic status
     */
    public Status checkStatus() {
        final Status status = new Status(MONGODB_UNIT, Level.LEVEL_0, new Date());
        try {
            final CommandResult result = serverStatus();
            if (!result.ok() && result.getErrorMessage().equals("unauthorized")) {
                setStatus(status, ping());
            } else {
                setStatus(status, result);
            }
        } catch (Exception e) {
            setStatusError(status, String.format("MongoDB status check error: %s", e.getLocalizedMessage()));
        } finally {
            return status;
        }
    }
}
