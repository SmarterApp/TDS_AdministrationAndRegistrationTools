/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.domain.Proctor;
import org.opentestsystem.delivery.testadmin.domain.ProctorRole;
import org.opentestsystem.delivery.testadmin.service.ProctorRoleService;
import org.opentestsystem.delivery.testadmin.service.ProctorService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentGroupRepository;
import org.opentestsystem.delivery.testreg.persistence.UserRepository;
import org.opentestsystem.delivery.testreg.persistence.UserSearchRepository;
import org.opentestsystem.delivery.testreg.persistence.UserServiceHelper;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.StudentGroupService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.opentestsystem.shared.security.integration.PermissionClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

/**
 * Implementation of User Service.
 */
@Service("userService")
public class UserServiceImpl<T extends User> extends Sb11NonEntityServiceImpl<T> implements UserService {
    
    @Resource(name = "sb11NonEntityService")
    private TestRegistrationService<? extends Sb11NonEntity> sb11NonEntityService;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;
    
    @Autowired
    private StudentGroupService studentGroupService;
    
    @Autowired
    private ProctorRoleService proctorRoleService;
    
    @Autowired
    private ProctorService proctorService;
    
    @Autowired
    private TestRegPersister testRegPersister;
    
    @Autowired
    private org.opentestsystem.shared.security.service.UserService userServiceSecurity;
    
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserSearchRepository userSearchRepository;
    
    @Autowired
    private StudentGroupRepository studentGroupRepository;
    
    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;
    
    @Autowired
    private PermissionClient permissionClient;
    
    @SuppressWarnings ("unchecked")
    @Override
    public T findById(final String pkId, final FormatType formatType) {
      return (T) performJoins(super.findById (pkId, formatType));
    }

    @Override
    // we are treating all updates and saves as upserts
    public T saveDomainObject(final T user) {
        List<T> list = Lists.newArrayList();
        if (user != null && StringUtils.isNotBlank(user.getId())) {
            // this is from the ui no need of upsert
            try {
                final Map<String, T> userMap = Maps.newHashMap();
                userMap.put(user.getEmail(), user);
                modifyStudentGroup(user);
                list = this.userRepository.save(userMap.values());
                if(list != null){
                  modifyProctors(user);
                }  
            } catch (final DuplicateKeyException dke) {
                final String alternateKey = user.getAlternateKey();
                throw new LocalizedException("entity.already.exists", new String[] { user.getFormatType().name(), alternateKey }, dke);
            }
        } else {
            list = saveDomainObjects(Collections.singletonList(user));
         }
        return list.size() > 0 ? list.get(0) : null;
    }


    /**
     * modify studentGroup based on whether email/firstName/lastName of 
     * existing user updated then corresponding studentGroup records will also updated
     * 
     * @param user : update user record
     */
    private void modifyStudentGroup (T user) {
      User dbUser = this.findById (user.getId (), user.getFormatType ());
      if (!dbUser.getEmail ().equals (user.getEmail ()) || !dbUser.getFirstName ().equalsIgnoreCase (user.getFirstName ()) || !dbUser.getLastName ().equalsIgnoreCase (user.getLastName ())) {
        List<StudentGroup> studentGroups = studentGroupService.findStudentGroupsByOwnerEmail (dbUser.getEmail ());
        if (studentGroups != null) {
          for (StudentGroup studentGroup : studentGroups) {
            studentGroup.setOwnerEmail (user.getEmail ());
            studentGroup.setOwnerFirstName (user.getFirstName ());
            studentGroup.setOwnerLastName (user.getLastName ());
            studentGroupRepository.save (studentGroup);
          }
        }
      }
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> saveDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> updateDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    private List<T> upsertDomainObjects(final List<T> userList) {
      
        final Map<String, T> userMap = combineDuplicateUsers(userList);
        mergeExistingRolesFromDB(userMap);
        setAssociatedEntityMongoIds(userMap);
        this.userSearchRepository.clearAccessibleUsersCache();
        for(T user: userMap.values()) {
          if (user.getId ()!= null) {
            modifyStudentGroup(user);
          }
        }
        List<T> savedUsersList = this.userRepository.save(userMap.values());
        
        for(T user: savedUsersList){
          modifyProctors(user);
        }
        return savedUsersList;
    }

    // when given a list of users to act on we should combine duplicates such that
    // we combine all role associations (other differing attributes might get munged)
    private Map<String, T> combineDuplicateUsers(final List<T> users) {
      final Map<String, T> userMap = Maps.newHashMap();
        for (final T user : users) {
            if (!userMap.containsKey(user.getEmail().toLowerCase ())) {
                userMap.put(user.getEmail().toLowerCase (), user);
            } else {
                final T userInMap = userMap.get(user.getEmail().toLowerCase ());
                userInMap.addRoleAssociations(user.getRoleAssociations());
                userInMap.setFirstName(user.getFirstName());
                userInMap.setLastName(user.getLastName());
                userInMap.setPhone(user.getPhone());
            }
        }
        return userMap;
    }
    
    /**
     * Deleting User/User.Role.
     *
     * @param pkId                  mongoId  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @param formatType            formatType of entity( User )
     *  
     */
    
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType, Set<String> accessibleIds) {
      // User performs delete action from UI then 
      // we check if user has roles outside logged-in-user jurisdiction
      // true will only modify the roles of existing dbUser
      // otherwise delete corresponding user
      User modifiedUser = this.findById (pkId, formatType, accessibleIds);
      User dbUser = findUserByCustomAlternateKey(modifiedUser);
      List<User.RoleAssociation> dbRoles = dbUser.getRoleAssociations();
      if(modifiedUser != null){
        if(modifiedUser.getHasRolesOutside ()){
          dbRoles.removeAll (modifiedUser.getRoleAssociations ());
          // checking user.Roles size greater than Zero or not 
          // yes will perform saving of modified user.roles record 
          // otherwise delete user record
          if(dbRoles.size () > 0){
            this.userRepository.save (dbUser) ;
            this.userSearchRepository.clearAccessibleUsersCache();
          }else{
            this.deleteDomainObject (pkId, formatType);
          }
        }else{
          this.deleteDomainObject (pkId, formatType);
        }
      }
    }
    
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {
      deleteStudentGroup(pkId, formatType);
      super.deleteDomainObject(pkId, formatType);
      Proctor dbProctor = proctorService.findProctorByUserId (pkId);
      if(dbProctor != null){
        proctorService.removeProctor (dbProctor);
      }
      this.userSearchRepository.clearAccessibleUsersCache();
    }

    /**
     * when user deletes a user record then check for corresponding studentGroup collection with user.emailId 
     * if studentGroup records found delete corresponding studentGroup records 
     * 
     * @param pkId         user mongoId
     * @param formatType   USER
     */
    private void deleteStudentGroup (String pkId, FormatType formatType) {
      User user = this.findById (pkId, formatType);
      List<StudentGroup> studentGroups = studentGroupService.findStudentGroupsByOwnerEmail (user.getEmail ());
      if (studentGroups != null) {
        for (StudentGroup studentGroup : studentGroups) {
          studentGroupRepository.delete (studentGroup);
        }
      }
    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        // User is not deleted instead roles are deleted
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                final User dbUser = findUserByCustomAlternateKey(domainObj);
                if (dbUser != null) {
                    final RoleAssociation uploadedRole = domainObj.getRoleAssociations().get(0);
                    for (final RoleAssociation role : dbUser.getRoleAssociations()) {
                        if (uploadedRole.equals(role)) {
                            dbUser.removeRoleAssociation(uploadedRole);
                            break;
                        }
                    }
                    updateDomainObject((T) dbUser);
                    modifyProctors(dbUser);
                    if(dbUser.getRoleAssociations().size() == 0){
                      deleteStudentGroup(dbUser.getId(), User.FORMAT_TYPE);
                      sb11NonEntityService.deleteDomainObject (dbUser.getId(), User.FORMAT_TYPE);
                  }
                }
            }
            this.userSearchRepository.clearAccessibleUsersCache();
        }
    }

    private void mergeExistingRolesFromDB(final Map<String, T> userMap) {
        for (final T userInMap : userMap.values()) {
            final User dbUser = findByAlternateKey(userInMap.createAlternateKeySearchRequest(), User.class);
            if (dbUser != null) {
                performJoins(dbUser);
                userInMap.addRoleAssociations(dbUser.getRoleAssociations());
                userInMap.setId(dbUser.getId());
            }
        }
    }

    // Note: Building custom search request using exact email match (rather than userObj.getAlternateKey() which uses REGEX)
    private User findUserByCustomAlternateKey(final User user) {
        final Map<String, String[]> params = new HashMap<>();
        params.put(UserSearchRequest.SEARCH_KEY_EMAIL_EXACT, new String[] { user.getEmail() });
        final AbstractSearchRequest searchRequest = new UserSearchRequest(params);
        return performJoins(super.findByAlternateKey(searchRequest, User.class));
    }

    @SuppressWarnings("unchecked")
    private void setAssociatedEntityMongoIds(final Map<String, T> userMap) {
        final Map<String, Sb11Entity> sb11EntityMap = new HashMap<>();
        for (final User userInMap : userMap.values()) {
            for (final RoleAssociation role : userInMap.getRoleAssociations()) {
                if (role.getAssociatedEntityMongoId() == null) {
                    Sb11Entity associatedEntity;
                    if (Sb11SuperEntity.class.isAssignableFrom(role.getLevel().getEntityClass())) {
                        final String key = role.getAssociatedEntityId() + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityId(role.getAssociatedEntityId(), (Class<Sb11SuperEntity>) role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    } else {
                        final String stateAbbreviation = role.getStateAbbreviation();
                        final String key = role.getAssociatedEntityId() + "-" + stateAbbreviation + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityIdAndStateAbbreviation(role.getAssociatedEntityId(), stateAbbreviation, role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    }
                    if (associatedEntity != null) {
                        role.setAssociatedEntityMongoId(associatedEntity.getId());
                    }
                }
            }
        }
    }
    
    @SuppressWarnings("unchecked")
	  @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest,final FormatType formatType) {
        return performJoins((SearchResponse<T>) this.userSearchRepository.search(searchRequest), searchRequest);
    }

    @Override
    public List<User> findAllByRoleAssociationLevel(final String associatedEntityId, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, level));
    }

    @Override
    public List<User> findUserByLevel(final String associatedEntityId, final String stateAbbreviation, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, stateAbbreviation, level));
    }

    @Override
    public List<User> findUserByLevel(final String level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(level));
    }

    @Override
    public User findByEmail(final String email) {
      return performJoins(this.userRepository.findByEmail(email));
    }

    @Override
    public List<User> findUsersByRoleName(final String roleName) {
        return performJoins(this.userRepository.findAllByRoleName(roleName));
    }
    
    /**
     * Getting logged-in-User .
     *  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @return                      User( logged-in-user ) 
     */
    
    @Override
    // getting logged-in-user 
    public User getLoggedInUser(Set<String> accessibleIds) {
      SbacUser sbacUser = userServiceSecurity.getCurrentUser();    
      User user = this.findByEmail (sbacUser.getEmail ());
      modifyUserWithAllowableRoles(sbacUser,user,accessibleIds);
      return user;
    }

    /**
     * Finding User.
     *
     * @param pkId                  mongoId  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @param formatType            formatType of entity( User )
     * @return                      User 
     */
    
    @Override
    public User findById(final String pkId, final FormatType formatType, Set<String> accessibleIds) {
      User user = performJoins(super.findById (pkId, formatType));
      modifyUserWithAllowableRoles(userServiceSecurity.getCurrentUser(),user,accessibleIds);
      return user;
    }
    
    /**
     * @param sbacUser
     * @param user
     * @param accessibleIds
     */
    private void modifyUserWithAllowableRoles (SbacUser sbacUser, User user, Set<String> accessibleIds) {
      TenantType level =  UserServiceHelper.getLoginUserRoleLevel(sbacUser);
      List<String> inAccessibleProtected = UserServiceHelper.getNotAllowedProtectedRoles(sbacUser,getProctedRoles ());
      modifyUserVisibilityRoles(user,accessibleIds,level,inAccessibleProtected);
    }
    
    /**
     * Getting all List of protected roles
     */
    @Override
    public List<String> getProctedRoles () {
      List<String> protectedUserRoleNames = new ArrayList<>();
      List<UserRole> protectedRolesList =  permissionClient.getRoles();
      if (protectedRolesList != null) {
        for (UserRole userRole : protectedRolesList) {
          if (userRole.isProtected()) {
            protectedUserRoleNames.add(userRole.getRole());
          }
        }
        return protectedUserRoleNames;
      } 
      return Collections.emptyList();
    }

    @SuppressWarnings ("unchecked")
    protected SearchResponse<T> performJoins(SearchResponse<T> searchResponse, AbstractSearchRequest abstractSearchRequest) {
      if (searchResponse == null)
        return null;
      List<User> users = performJoins((List<User>) searchResponse.getSearchResults());
      int recordsRemoved = 0;
      Set<User> allUsers  = new HashSet<User> ();
      List<User> userWithProtectedRoles = new ArrayList<User> (); 
      UserSearchRequest userSearchRequest = (UserSearchRequest) abstractSearchRequest;
      SbacUser sbacUser = userServiceSecurity.getCurrentUser();
      TenantType level =  UserServiceHelper.getLoginUserRoleLevel(sbacUser);
      List<String> modList = UserServiceHelper.getNotAllowedProtectedRoles(sbacUser,getProctedRoles ());
      // If logged-in-user level is client then
      // Getting list of users whose role match with non accessible protectedRoles 
      if (level != null && level.equals (TenantType.CLIENT)) {
        for(String roleName : modList) {
          allUsers.addAll(findUsersByRoleName(roleName));
        }
        for(User usr : allUsers){
          // Checking if searchResults of logged-in-user contains user with not accessible protectedRole
          if(users.contains (usr)) {
            userWithProtectedRoles.add (usr);
          }
        }
        // modifying only user records that contains user with protectedRoles
        modifyUsers(userWithProtectedRoles, userSearchRequest.getAccessibleEntityIds (), level,modList);
        // removing user with protectedRoles from searchResults(list of users)
        users.removeAll (userWithProtectedRoles);
        for(User usr: userWithProtectedRoles){
          // If user with no roleAssociations(zero roles) then don't show user record to logged-in-user
          if(usr.getRoleAssociations ().size () == 0) {
            recordsRemoved ++;
          } else { // adding users(user with modified roles) back to search results
            users.add (usr);
          }
        }
        searchResponse = new SearchResponse<T>((List<T>)users, abstractSearchRequest, searchResponse.getTotalCount ()-recordsRemoved);
      } else if (level != null){
        modifyUsers(users, userSearchRequest.getAccessibleEntityIds (), level,modList);
        List<User> usersWithNoRole = new ArrayList<User>(); 
        for (User user : users) {
          if(user.getRoleAssociations ().size () == 0) {
            usersWithNoRole.add (user);
          } 
        }
        if (!usersWithNoRole.isEmpty ()) {
          users.removeAll (usersWithNoRole);
          searchResponse = new SearchResponse<T>((List<T>)users, abstractSearchRequest, searchResponse.getTotalCount ()-usersWithNoRole.size ());
        }
      }
      return searchResponse;
    }
    
    /**
     * @param users
     * @param accessibleEntityIds
     * @param level
     * @param modList
     */
    private void modifyUsers (List<User> users, Set<String> accessibleEntityIds, TenantType level, List<String> modList) {
      if (users != null) { 
        for (User user : users) {
          modifyUserVisibilityRoles(user,accessibleEntityIds,level,modList);
        }
      }
    }
    
    /**
     * Modify the user roles based on logged-in user( list of allowed associatedEntityIds ).
     *
     * @param user                        userEntity which we need to modify 
     * @param accessibleIds               Set of all entities( mongoIds ) that current user has access to
     * @param inAccessibleProtected       List of ProctedRoles logged-in-user don't have access
     * @param level                       Logged-in-user level
     * 
     */
    @SuppressWarnings ("unchecked")
    private void modifyUserVisibilityRoles(User user, Set<String> accessibleIds,TenantType level,List<String> inAccessibleProtected){
      if (user != null) {
        List<RoleAssociation> userRoles = user.getRoleAssociations ();
        if (level != null) {
          List<RoleAssociation> modifiedUserRoles = new ArrayList<RoleAssociation>();
          for (RoleAssociation roleAssociation : userRoles) {
            // If user roleAssociation mongoId is not null 
            if (roleAssociation.getAssociatedEntityMongoId () != null) {
              getModifiedUserRoles(modifiedUserRoles,roleAssociation.getAssociatedEntityMongoId (),accessibleIds,inAccessibleProtected,roleAssociation);
            } else if (roleAssociation.getAssociatedEntityId() != null) { // Checking for associatedEntityId is not null
              // looking for corresponding institution/state/client/GOS/GOI/GOD user roleAssociated based on associatedEntityId and level 
              Sb11Entity sb11EntityLookup = null;
              if (roleAssociation.getLevel().isSuperEntity()) {
                sb11EntityLookup = sb11EntityService.findByEntityId(roleAssociation.getAssociatedEntityId(),
                    (Class<Sb11SuperEntity>) roleAssociation.getLevel().getEntityClass());
              } else {
                String stateAbbrev = roleAssociation.getStateAbbreviation();
                sb11EntityLookup = sb11EntityService.findByEntityIdAndStateAbbreviation(roleAssociation
                    .getAssociatedEntityId(), stateAbbrev, roleAssociation.getLevel().getEntityClass());
              }
              if (sb11EntityLookup != null) {
                getModifiedUserRoles(modifiedUserRoles,sb11EntityLookup.getId (),accessibleIds,inAccessibleProtected,roleAssociation);
              }
            }
          }
          // Checking user being edited has roles outside the logged-in userâ€™s jurisdiction or not 
          if (userRoles.size () > modifiedUserRoles.size ()) {
            user.setHasRolesOutside (true);
          } else {
            user.setHasRolesOutside (false);
          }
          user.setRoleAssociations (modifiedUserRoles);
        }
      }
    }

    /**
     * If Logged-in-user can have access to associatedEntityMongoId and Role( ProtectedRoles ) Then add corresponding roleAssocition to List
     * 
     * @param modifiedUserRoles
     * @param associatedEntityMongoId  mongoId of userRoleAssoiation 
     * @param accessibleIds            set of all accessible mongoIds of logged-in-user 
     * @param modList                  set of not allowable protectedRoles for logged-in-user
     * @param roleAssociation 
     */
    private void getModifiedUserRoles (List<RoleAssociation> modifiedUserRoles, String associatedEntityMongoId, Set<String> accessibleIds, List<String> modList, RoleAssociation roleAssociation) {
      if (accessibleIds.contains (associatedEntityMongoId) && !modList.contains (roleAssociation.getRole ())) {
        modifiedUserRoles.add (roleAssociation);
      }
    }

    protected List<User> performJoins(List<User> users) {
      if (users == null)
        return null;
      for (User user : users)
        performJoins(user);
      return users;
    }

    protected User performJoins(User user) {
      if (user == null)
        return null;
      // right now we are only interested in associated entity information.
      // but there could be others in the future. this is a placeholder for
      // that.
      return updateUserWithEntityInformation(user);
    }

    private User updateUserWithEntityInformation(User u) {
      if (u == null)
        return null;
      // Update the user with any entity information here e.g.
      // associated entity name.
      if (u.getRoleAssociations() != null) {
        List<User.RoleAssociation> roles = u.getRoleAssociations();
        if (roles != null) {
          for (User.RoleAssociation role : roles) {
            if (role.getAssociatedEntityMongoId() != null) {
              Sb11Entity resEntity = testRegPersister.findById(role.getAssociatedEntityMongoId(), FormatType.valueOf(role.getLevel().toString()));
              if (resEntity != null)
              role.setAssociatedEntityName (resEntity.getEntityName());
            }
          }
        }
      }
      return u;
    }
    
    private void modifyProctors(User user){
      if (user != null) {
        List<RoleAssociation> userRoles = user.getRoleAssociations ();
        List<ProctorRole> proctorRoles = proctorRoleService.getAllProctorRolesAvailable ();
        List<String> userRoleNames = new ArrayList<String> ();
        List<String> proctorRoleNames = new ArrayList<String>();
        Proctor proctor = null;
        proctor = new Proctor ();
        proctor.setUser (user);

        for (RoleAssociation role : userRoles)
          userRoleNames.add (role.getRole ());

        for (ProctorRole procRole : proctorRoles)
          proctorRoleNames.add (procRole.getName ());
        Proctor dbProctor = proctorService.findProctorByUserId (user.getId ());
        for (String proctorRoleName : proctorRoleNames) {
          if (userRoleNames.contains (proctorRoleName)) {
            if (dbProctor == null) {
              proctorService.saveProctor (proctor);
              break;
            } else {
              dbProctor.setUser (user);
              proctorService.saveProctor (dbProctor);
              break;
            }

          } else {
            if (dbProctor != null) {
              proctorService.removeProctor (dbProctor);
              break;
            }

          }
        }
      }
    }

}
