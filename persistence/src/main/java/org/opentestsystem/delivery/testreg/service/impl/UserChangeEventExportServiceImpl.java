/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.opentestsystem.delivery.Sb11TimeZoneBuilder;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.MnaAlertType;
import org.opentestsystem.delivery.testreg.domain.SSOAction;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.UserChangeEvent;
import org.opentestsystem.delivery.testreg.service.FileTransferService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.UserChangeEventExportService;
import org.opentestsystem.delivery.testreg.service.UserChangeEventService;
import org.opentestsystem.shared.mna.client.domain.MnaSeverity;
import org.opentestsystem.shared.mna.client.service.AlertBeacon;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Sort;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.DomDriver;

@Service
public class UserChangeEventExportServiceImpl implements UserChangeEventExportService {

    private static final Logger LOGGER = LoggerFactory.getLogger(UserChangeEventExportServiceImpl.class);
    private static final String UTF8 = "UTF-8";
    
    @Autowired
    private UserChangeEventService userChangeEventService;

    @Autowired
    private FileTransferService fileTransferService;

    @Autowired
    private TestRegPersister userService;
    
    @Autowired
    private Sb11EntityServiceImpl<? extends Sb11Entity> sb11EntityService;
    
    @Autowired
    private Sb11TimeZoneBuilder              sb11TimeZoneBuilder;

    @Autowired
    private AlertBeacon alertBeacon;
    
    @Value("${testreg.sso.filename.suffix:}")
    private String fileNameSuffix;
    
    @Override
    @Scheduled(initialDelayString = "${testreg.user.export.frequency.milliseconds:120000}", fixedDelayString = "${testreg.user.export.frequency.milliseconds:120000}")
    public void exportUserChangeEvents() {
        int userChangeEventsAddedToXML = 0;
        List<UserChangeEvent> userChangeEvents = userChangeEventService.findAll(new Sort(Sort.Direction.ASC,"timestamp"));
        if (userChangeEvents.size() > 0) {
            userChangeEventService.delete(userChangeEvents);
            long changeEventsUpToTimestamp = userChangeEvents.get(userChangeEvents.size() - 1).getTimestamp();
            String exportFileName = "accounts_" + changeEventsUpToTimestamp + "_" + UUID.randomUUID ().toString () + fileNameSuffix + ".xml";
            try {
                LOGGER.debug("exporting " + userChangeEvents.size() + " user change events");
                StringBuilder userChangeEventsAsXML = new StringBuilder();
                userChangeEventsAsXML.append("<?xml version='1.0' encoding='" + UTF8 + "'?>\n");
                userChangeEventsAsXML.append("<Users>\n");
                for (UserChangeEvent userChangeEvent : userChangeEvents) {
                    try {
                        LOGGER.debug("processing user change event id: " + userChangeEvent.getId() + " (user id: "
                                + userChangeEvent.getModifiedUserId() + ")");
                        userChangeEventsAsXML.append(convertToXML(userChangeEvent)).append("\n");
                        userChangeEventsAddedToXML++;
                    } catch (CannotExportUserChangeEventException ex) {
                        LOGGER.warn("Skipping user change event for user (" + userChangeEvent.getModifiedUserId()
                                + "): Action: (" + userChangeEvent.getAction()
                                + "): " + ex.getMessage());
                    }
                }
                userChangeEventsAsXML.append("</Users>");
                if (userChangeEventsAddedToXML > 0) {
                    LOGGER.debug("\n\n" + userChangeEventsAsXML.toString() + "\n");
                    fileTransferService.writeFile(exportFileName, userChangeEventsAsXML.toString());
                    alertBeacon.sendAlert(MnaSeverity.INFO, MnaAlertType.SSO_USER_EXPORT.name(),
                            "user change event export successful");
                }
            } catch (Exception ex) {
                userChangeEventService.saveUserChangeEvents(userChangeEvents);
                String errorMessage = "problem processing user change events to export!";
                LOGGER.error(errorMessage, ex);
                alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.SSO_USER_EXPORT.name(),
                        errorMessage + ": " + ex.getMessage());
            }
        }
    }

    private String convertToXML(final UserChangeEvent userChangeEvent) {
        XStream xStream = new XStream(new DomDriver());
        xStream.registerConverter(new UserChangeEventXmlConverter());
        xStream.registerConverter(new UserXmlConverter());
        xStream.registerConverter(new RoleAssociationXmlConverter());
        xStream.alias("User", UserChangeEvent.class);
        xStream.alias("Role", User.RoleAssociation.class);
        return xStream.toXML(userChangeEvent);
    }

    // convert a user change event into XML
    private class UserChangeEventXmlConverter extends OneWayConverter {

        @SuppressWarnings("rawtypes")
        @Override
        public boolean canConvert(final Class clazz) {
            return clazz.equals(UserChangeEvent.class);
        }

        @Override
        public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {
            UserChangeEvent userChangeEvent = (UserChangeEvent) source;
            SSOAction action = userChangeEvent.getAction();
            
            DateTime now = new DateTime (sb11TimeZoneBuilder.getDateTimeZone ());
            
            DateTimeFormatter fmt = DateTimeFormat.forPattern ("EEEE, MMMM d, Y");
            
            DateTimeFormatter fmt2 = DateTimeFormat.forPattern ("k:ma z");
            String dateStr = fmt.print (now) +", at "+fmt2.print (now);
            
            writer.addAttribute("Action", action.toString());

            if (action.equals(SSOAction.DEL)) {
                addTag("UUID", userChangeEvent.getModifiedUserId(), writer);
                return;
            }

            // check to make sure user exists prior to handling any other user change event action
            User user = userService.findById(userChangeEvent.getModifiedUserId(), FormatType.USER);
            if (user == null) {
                throw new CannotExportUserChangeEventException("User (id: " + userChangeEvent.getModifiedUserId()
                        + ") disappeared during user change event processing.");
            }

            if (action.equals(SSOAction.LOCK) || action.equals(SSOAction.UNLOCK) || action.equals(SSOAction.RESET)) {
                addTag("UUID", userChangeEvent.getModifiedUserId(), writer);
                if (action.equals(SSOAction.RESET)) {
                    addTag("Email", user.getEmail(), writer);
                    if(StringUtils.isNotBlank(userChangeEvent.getRequesterFullName ()) && StringUtils.isNotBlank(userChangeEvent.getRequesterEmailId ())){
                      // Based on requirement 3.4 of TO-15(SB-1426) Message node is added to provisioning XML 
                      // Message node contains information about name of the coordinator who initiated the reset
                      String message = "Your password was reset by " + userChangeEvent.getRequesterFullName () + " ( " + userChangeEvent.getRequesterEmailId () + " ) on " + dateStr;
                      addTag("Message", message, writer);
                    }
                }
            } else if (action.equals(SSOAction.ADD)) {
                context.convertAnother(user);
            } else if (action.equals(SSOAction.MOD)) {
                if (user.getChangeEventExportError() == null) {
                    context.convertAnother(user);
                } else {
                    // this is the special case where we previously had a problem exporting this user, since we received
                    // an ack by the
                    // receiver with an error, and now the user object holds the error message, and the testreg UI
                    // indicates the problem,
                    // so human intervention is needed to fix the problem (and then most likely a SYNC will need to be
                    // done to retry)
                    throw new CannotExportUserChangeEventException("user already has previous export errors");
                }
            } else if (action.equals(SSOAction.SYNC)) {
                if (user.getChangeEventExportError() != null) {
                    // this is the special case where we previously had a problem exporting this user, since we received
                    // an ack by the
                    // receiver with an error, and now the user object holds the error message, and the testreg UI
                    // indicates the problem,
                    // so human intervention was needed to fix the problem (this SYNC operation sets the error message
                    // back to null)
                    user.setChangeEventExportError(null);
                    userService.saveDomainObject(user);
                }
                context.convertAnother(user);
            }
        }
    }

    // convert a User object into XML
    private class UserXmlConverter extends OneWayConverter {

        @SuppressWarnings("rawtypes")
        @Override
        public boolean canConvert(final Class clazz) {
            return clazz.equals(User.class);
        }

        @Override
        public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {
            User user = (User) source;

            addTag("UUID", user.getId(), writer);
            addTag("FirstName", user.getFirstName(), writer);
            addTag("LastName", user.getLastName(), writer);
            addTag("Email", user.getEmail(), writer);
            addTag("Phone", user.getPhone(), writer);

            for (User.RoleAssociation roleAssociation : user.getRoleAssociations()) {
                context.convertAnother(roleAssociation);
            }
        }
    }

    // convert a RoleAssociation object into XML
    private class RoleAssociationXmlConverter extends OneWayConverter {

        @SuppressWarnings("rawtypes")
        @Override
        public boolean canConvert(final Class clazz) {
            return clazz.equals(User.RoleAssociation.class);
        }

        @Override
        public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {
            User.RoleAssociation roleAssociation = (User.RoleAssociation) source;

            writer.startNode("Role");
            // =========================== start Role tag

            addTag("RoleID", roleAssociation.getAssociatedEntityId(), writer);
            addTag("Name", roleAssociation.getRole(), writer);
            addTag("Level", roleAssociation.getLevel().getProgmanEnumName(), writer);

            // write out our role hierarchy information as xml
            for (List<String> vals : Lists.reverse(hydrateHierarchyValues(roleAssociation))) {
                addTag(vals.get(0) + "ID", vals.get(1), writer);
                addTag(vals.get(0), vals.get(2), writer);
            }

            // =========================== end Role tag
            writer.endNode();
        }
    }

    // convenience class to hide the unused method that must be implemented
    private static abstract class OneWayConverter implements Converter {
        @Override
        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {
            // we shouldn't ever use this method!
            throw new RuntimeException("Not Implemented!");
        }
    }

    // this traverses the hierarchy filling in names/values to prep for xml output
    private List<List<String>> hydrateHierarchyValues(final User.RoleAssociation roleAssociation) {
        List<List<String>> roleHierarchyInfo = new ArrayList<>();

        String currentEntityMongoId = roleAssociation.getAssociatedEntityMongoId();
        String currentEntityId = roleAssociation.getAssociatedEntityId();
        HierarchyLevel currentHierarchyLevel = roleAssociation.getLevel();

        for (HierarchyLevel hierarchyLevel : Lists.reverse(Arrays.asList(HierarchyLevel.values()))) {
            if (!hierarchyLevel.equals(HierarchyLevel.CLIENT)) {
                if (currentHierarchyLevel.equals(hierarchyLevel)) {
                    Sb11Entity sb11Entity = sb11EntityService.findById(currentEntityMongoId,
                            FormatType.valueOf(currentHierarchyLevel.name()));
                    if (sb11Entity != null) {
                        LOGGER.debug("looking up hierarchy level: " + sb11Entity.toString());
                        currentHierarchyLevel = sb11Entity.getParentEntityType();
                        currentEntityId = sb11Entity.getParentEntityId();
                        currentEntityMongoId = sb11Entity.getParentId();
                        roleHierarchyInfo.add(Arrays.asList(FormatType.valueOf(hierarchyLevel.name()).getFormatName(),
                                sb11Entity.getEntityId(), sb11Entity.getEntityName()));
                    } else {
                        throw new CannotExportUserChangeEventException("missing sb11 entity [id: " + currentEntityMongoId + ", type: "
                                + FormatType.valueOf(currentHierarchyLevel.name()) + "]");
                    }
                } else {
                    roleHierarchyInfo.add(Arrays.asList(FormatType.valueOf(hierarchyLevel.name()).getFormatName(),
                            null, null));
                }
            }
        }

        List<ClientEntity> clientList = userService.findAll(FormatType.CLIENT);
        ClientEntity theClient = clientList.get(0);

        roleHierarchyInfo.add(Arrays.asList("Client", currentEntityId, theClient.getEntityName()));
        return roleHierarchyInfo;
    }

    // helper method to create a simple xml tag with null and empty string checking
    private void addTag(final String tagName, final String value, final HierarchicalStreamWriter writer) {
        writer.startNode(tagName);
        if (value != null && value != "") {
            writer.setValue(value);
        }
        writer.endNode();
    }

    private static class CannotExportUserChangeEventException extends RuntimeException {

        private static final long serialVersionUID = -3689099923731890669L;

        public CannotExportUserChangeEventException(String reason) {
            super(reason);
        }
    }
}
